<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>core.hydromet - pfra-hydromet</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "core.hydromet";
    var mkdocs_page_input_path = "hydromet.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> pfra-hydromet</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../about/">About</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../CHANGELOG/">Changelog</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../CONTRIBUTING/">Contributing</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../setup/">Setup</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../quickstart/">Quickstart</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../core/">Core</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">pfra-hydromet</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>core.hydromet</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="corehydromet">core.hydromet</h1>
<h2 id="parse_filename">parse_filename</h2>
<pre><code class="python">parse_filename(zip_name:str, reg:str) -&gt; dict
</code></pre>

<p>Builds a dictionary with the region, recurrance interval, duration,
and statistic type using the zip_name and region.</p>
<h2 id="get_masked_mean_atlas14">get_masked_mean_atlas14</h2>
<pre><code class="python">get_masked_mean_atlas14(gdf:'GeoDataFrame', raster:str) -&gt; float
</code></pre>

<p>Masks the Atlas 14 precipitation raster by the passed polygon and then
calculates the average precipitation for the masked polygon.</p>
<h2 id="get_input_data">get_input_data</h2>
<pre><code class="python">get_input_data(precip_table_dir:str, duration:int, lower_limit:int=2, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Extracts the precipitation frequency data for the specified duration
from an Excel sheet and returns the dataframe with the data.</p>
<h2 id="get_temporal_map">get_temporal_map</h2>
<pre><code class="python">get_temporal_map(data_dir:str, filename:str, vol:int, reg:int, dur:int, display_print:bool=True) -&gt; dict
</code></pre>

<p>Reads the json file containing the temporal distribution data metadata
and returns the data map and number of rows to skip for the specified
volume, region, and duration.</p>
<h2 id="get_temporals">get_temporals</h2>
<pre><code class="python">get_temporals(temporal_dir:str, vol:int, reg:int, dur:int, qmap:dict, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Reads the csv file containing the temporal distributions for the
specified volume, region, and duration. Rows with NaNs for an index
are dropped. Data was downloaded from:
https://hdsc.nws.noaa.gov/hdsc/pfds/pfds_temporal.html</p>
<h2 id="get_quartile_rank">get_quartile_rank</h2>
<pre><code class="python">get_quartile_rank(data_dir:str, filename:str, vol:int, reg:int, dur:int, display_print:bool=True) -&gt; list
</code></pre>

<p>Extracts the quartile ranks for the specified volume, region, and
duration. The quartile rank corresponds to the percentage of
precipitation events whose temporal distributions are represented
by those in a specific quartile.</p>
<h2 id="get_duration_weight">get_duration_weight</h2>
<pre><code class="python">get_duration_weight(data_dir:str, filename:str, vol:int, reg:int, dur:int, display_print:bool=True) -&gt; list
</code></pre>

<p>Extracts the duration weight for the specified volume, region, and
duration. The duration weight corresponds to the percentage of
precipitation events with the specified duration.</p>
<h2 id="get_cn_distribution">get_CN_distribution</h2>
<pre><code class="python">get_CN_distribution(data_dir:str, filename:str, CN:int, display_print:bool=True) -&gt; dict
</code></pre>

<p>Open the json file containing the curve number values for different
antecedent moisture conditions and return the values for the
specified curve number.</p>
<h2 id="extrap_add_ari">extrap_add_ari</h2>
<pre><code class="python">extrap_add_ari(df:pandas.core.frame.DataFrame, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Calls the add_ari function to update the dataframe and
then calls the extrapolate_extremes function in order to extrapolate
the confidence limits and expected value of the precipitation amount
for the 2000 and 3000 year return periods.</p>
<h2 id="add_ari">add_ari</h2>
<pre><code class="python">add_ari(df:pandas.core.frame.DataFrame) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Calculates the annual exceedance probability (AEP),
average recurrance interval (ARI), and log of the ARI and adds the
results to the original dataframe.</p>
<h2 id="extrapolate_extremes">extrapolate_extremes</h2>
<pre><code class="python">extrapolate_extremes(df:pandas.core.frame.DataFrame, rp:int, ycol:str) -&gt; float
</code></pre>

<p>Extrapolates the ycol for the specified return period.</p>
<h2 id="generate_random_samples">generate_random_samples</h2>
<pre><code class="python">generate_random_samples(samplesize:int, seed:int=None, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Selects the specified number of random samples from a continuous
normal distribution, calculates the inverse of the sample, and saves
the results in a dataframe with column "Tr", where "Tr" is the
recurrance interval.</p>
<h2 id="truncate_random_events">Truncate_Random_Events</h2>
<pre><code class="python">Truncate_Random_Events(r_events:pandas.core.frame.DataFrame, lower_limit:int=2, upper_limit:int=3000) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Removes events with recurrance intervals less than the lower_limit
(typically 2 years) and sets recurrance intervals greater than the
upper limit (typically 3000 years) eqaul to the upper limit.</p>
<h2 id="events_table_random">events_table_random</h2>
<pre><code class="python">events_table_random(raw_precip:pandas.core.frame.DataFrame, events_table:pandas.core.frame.DataFrame) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Calls the add_ari function to update the dataframe and then calls the
scipy_interp function in order calculate the expected value, lower
(90%) confidence limits, and upper (90%) confidence limits for the
events_table given the raw_precip dataframe.</p>
<h2 id="scipy_interp">scipy_interp</h2>
<pre><code class="python">scipy_interp(raw_precip:pandas.core.frame.DataFrame, df:pandas.core.frame.DataFrame, ynew:str='Expected Value') -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Interpolates the ynew values for the passed df given the Log10_ARI
and ynew valuea contained within the raw_precip dataframe.</p>
<h2 id="find_optimal_curve_std">find_optimal_curve_std</h2>
<pre><code class="python">find_optimal_curve_std(df:pandas.core.frame.DataFrame, lower:str='Lower (90%)', upper:str='Upper (90%)', sdev:float=0.15) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Calculates/optimizes the standard deviation of the lognormal
distribution using the expected value, lower confidence limit/value,
and the upper confidence limit/value. The sum of the squared residuals
of the lower and upper confidence limits/values is used as the test
statistic (this statistic is minimized). Note that the sdev is the
initial estimate of the standard deviation. The fitted values should
be compared to the lower and upper confidence limits/values to
validate the optimization. Note: additional code exists at the end of
the script containing this function which can be edited in order to
improve the fit of the standard devation for CN.</p>
<h2 id="randomizedata">RandomizeData</h2>
<pre><code class="python">RandomizeData(df:pandas.core.frame.DataFrame, number:int, results_dir:str, AOI:str, duration:int=24, quartile:int=None, seed:int=None, sampling_distro:str='Lognorm', variable:str='Precipitation', lower:str='Lower (90%)', upper:str='Upper (90%)', plot:bool=False, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Randomly selects a value (precipitation or curve number) from the log-
normal distribution given the expected value and optimized standard
devation for each recurrance interval/event.</p>
<h2 id="join_rdata_tables">join_rdata_tables</h2>
<pre><code class="python">join_rdata_tables(rdata_tables:list, type:str, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Concatenates the dataframe elements of the passed list producing a
single dataframe. This resulting dataframe's index is set from 1 to
the length of the dataframe.</p>
<h2 id="get_quartiles">get_quartiles</h2>
<pre><code class="python">get_quartiles(raw_temporals:pandas.core.frame.DataFrame, dur:int, qrank:list, qmap:dict, vol:int, reg:int, plot:bool=False) -&gt; dict
</code></pre>

<p>For each quantile, extract the temporal data from the raw_temporals
dataframe, convert the data to numeric, store the data in a dictionary,
and plot the deciles.</p>
<h2 id="map_quartiles_deciles">map_quartiles_deciles</h2>
<pre><code class="python">map_quartiles_deciles(n_samples:int=75, seed:int=None, plot:bool=False, display_print:bool=True) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Constructs a dataframe containing randomly selected deciles for the
specified number of samples (events).</p>
<h2 id="prep_cn_table">prep_cn_table</h2>
<pre><code class="python">prep_cn_table(CN:int, arc_data:dict) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Constructs a dataframe with the average/expected curve number (CN),
the dry/lower CN, and the wet/upper CN. The dry, average, and wet
curve numbers refer to different antecedent runoff conditions, which
were obtained from NEH Part 630, Chapter 10, Table 10-1
(https://www.wcc.nrcs.usda.gov/ftpref/wntsc/H&amp;H/NEHhydrology/ch10.pdf)</p>
<h2 id="populate_event_precip_data">populate_event_precip_data</h2>
<pre><code class="python">populate_event_precip_data(random_cns:pandas.core.frame.DataFrame, temporals:pandas.core.frame.DataFrame, random_precip_table:pandas.core.frame.DataFrame, data_table:pandas.core.frame.DataFrame, curve_group:dict, dur:int=24, adjust_CN_less24:bool=False) -&gt; (&lt;class 'pandas.core.frame.DataFrame'&gt;, &lt;class 'pandas.core.frame.DataFrame'&gt;, &lt;class 'pandas.core.frame.DataFrame'&gt;, &lt;class 'pandas.core.frame.DataFrame'&gt;)
</code></pre>

<p>Calculates cumulative and incremental runoff for each event using a
randomly selected precipitation amount, quartile specific temporal
distribution, and curve number.</p>
<h2 id="update_cn">update_CN</h2>
<pre><code class="python">update_CN(CN:int, duration:int, grid_avg_precip:float) -&gt; (&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'float'&gt;)
</code></pre>

<p>Adjusts the curve number (CN), potential maximum retention after
runoff begins (S), and intial abstraction (Ia) for durations less than
24 hours. Contact Kaveh Zomorodi: kzomorodi@Dewberry.com for
additional details regarding the adj_CN equation.</p>
<h2 id="s_24hr">S_24hr</h2>
<pre><code class="python">S_24hr(CN:int) -&gt; float
</code></pre>

<p>Calculates the potential maximum retention after runoff begins (S), in
inches.</p>
<h2 id="ia_24hr">IA_24hr</h2>
<pre><code class="python">IA_24hr(s24:float) -&gt; float
</code></pre>

<p>Calculats the inital abstraction (Ia) as a function of the maximum
potentail rention (S). Lim et al. (2006) suggest that a 5% ratio of
Ia to S is more appropriate for urbanized areas instead of the more
commonly used 20% ratio
(https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1752-1688.2006.tb04481.x).</p>
<h2 id="qcn_24hr">QCN_24hr</h2>
<pre><code class="python">QCN_24hr(grid_avg_precip:float, s24:float) -&gt; float
</code></pre>

<p>Calculates runoff using equation 10-11 of NEH Part 630, Chapter 10
(https://www.wcc.nrcs.usda.gov/ftpref/wntsc/H&amp;H/NEHhydrology/ch10.pdf).</p>
<h2 id="infiltration_24hr">infiltration_24hr</h2>
<pre><code class="python">infiltration_24hr(grid_avg_precip:float, s24:float, qcn_24:float) -&gt; float
</code></pre>

<p>Calculates the actual retention (or infilitration) after runoff
begins, in inches using equation 10-7 of NEH Part 630, Chapter 10
(https://www.wcc.nrcs.usda.gov/ftpref/wntsc/H&amp;H/NEHhydrology/ch10.pdf).</p>
<h2 id="calculate_excess">calculate_excess</h2>
<pre><code class="python">calculate_excess(precip:float, ia:float, s:float) -&gt; float
</code></pre>

<p>Calculates runoff using the curve number approach. See equation 10-9
of NEH 630, Chapter 10
(https://www.wcc.nrcs.usda.gov/ftpref/wntsc/H&amp;H/NEHhydrology/ch10.pdf)</p>
<h2 id="adjust_incremental">adjust_incremental</h2>
<pre><code class="python">adjust_incremental(raw:pandas.core.series.Series, excess:pandas.core.series.Series) -&gt; pandas.core.series.Series
</code></pre>

<p>Calculates the incremental runoff depth (depth/timestep) using the
cumulative_to_incremental function, and then redistributes the first
non-zero incremental runoff value over the prior timesteps using the
incremental precipitation as a weighting function.</p>
<h2 id="cumulative_to_incremental">cumulative_to_incremental</h2>
<pre><code class="python">cumulative_to_incremental(vector:pandas.core.series.Series) -&gt; pandas.core.series.Series
</code></pre>

<p>Converts the cumulative depth (precipitation or runoff) into the
incremental depth, i.e. the depth/timestep (rate).</p>
<h2 id="convert_tempepsilon">convert_tempEpsilon</h2>
<pre><code class="python">convert_tempEpsilon(tempEpsilon:float, incr_excess:pandas.core.frame.DataFrame) -&gt; int
</code></pre>

<p>Converts the tempEpsilon from the number of hours to the number of
corresponding timesteps.</p>
<h2 id="bin_sorting_dev">bin_sorting_dev</h2>
<pre><code class="python">bin_sorting_dev(incr_excess:pandas.core.frame.DataFrame, nbins:int, display_print:bool=True) -&gt; list
</code></pre>

<p>Computes the histogram of the series data with the specified number
of bins and returns the results as a list.</p>
<h2 id="get_bin_slice">get_bin_slice</h2>
<pre><code class="python">get_bin_slice(incr_excess:pandas.core.frame.DataFrame, binstart:float, binstop:float) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Slices the passed dataframe based on the events whose total runoff is
bound by binstart and binstop.</p>
<h2 id="prep_data_for_convolution">prep_data_for_convolution</h2>
<pre><code class="python">prep_data_for_convolution(dataslice:pandas.core.frame.DataFrame, adj_tempEpsilon:int) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>The runoff for each column (event) in the passed dataframe is
calculated from zero to 24 hours for the intervals of length
tempEpsilon*timstep (30 minutes).</p>
<h2 id="test_shapes">test_shapes</h2>
<pre><code class="python">test_shapes(dataslice:pandas.core.frame.DataFrame, col:str, adj_tempEpsilon:int) -&gt; nptyping.Array
</code></pre>

<p>Calculates the total runoff for each interval, where the interval
width is equal to tempEpsilon times the timestep (30 minutes).</p>
<h2 id="conv_ts">conv_ts</h2>
<pre><code class="python">conv_ts(curve_test_df:pandas.core.frame.DataFrame, convEpsilon:float=150.0, volEpsilon:float=50.0) -&gt; (&lt;class 'dict'&gt;, &lt;class 'list'&gt;)
</code></pre>

<p>For each event combination, a test statistic is calculated in order
to quantify the similarity between the two temporal distributions.
Note that in this function's code, "c" and "nc" refer to "column"
and "next column", respectively.</p>
<h2 id="test_stat">test_stat</h2>
<pre><code class="python">test_stat(c_df:pandas.core.frame.DataFrame, nc_df:pandas.core.frame.DataFrame, c:str, nc:str, convEpsilon:float, volEpsilon:float) -&gt; float
</code></pre>

<p>Calculates a test statistic that quantifies the similarity between
the two curves defined by "c" and "nc" within the passed dataframes.
Note that in this function's code, "c" and "nc" refer to "column"
and "next column", respectively.</p>
<h2 id="group_curves">group_curves</h2>
<pre><code class="python">group_curves(test_dic:dict, test_values:list, events:list, test_stat_threshold:float=0.0) -&gt; dict
</code></pre>

<p>If the test statistic for a particular pair of events is greater than
the threshold and neither of the events are already in a group, add
them to a new group. Add all curves that are not a part of a group,
to their own group.</p>
<h2 id="calc_mean_curves">calc_mean_curves</h2>
<pre><code class="python">calc_mean_curves(curve_group:dict, dataslice:pandas.core.frame.DataFrame) -&gt; pandas.core.frame.DataFrame
</code></pre>

<p>Calculate the mean of the temporal distributions within each group.</p>
<h2 id="check_upd_curv">check_upd_curv</h2>
<pre><code class="python">check_upd_curv(all_groups:dict, updated_curves:pandas.core.frame.DataFrame, df:pandas.core.frame.DataFrame, convEpsilon:float, volEpsilon:float, test_stat_threshold:float) -&gt; (&lt;class 'dict'&gt;, &lt;class 'pandas.core.frame.DataFrame'&gt;)
</code></pre>

<p>The temporal distribution for each event within a group used to
calculate a mean temporal distribution is compared to that mean
temporal distribution using the same test statistic used to intially
combine the distributions into groups. If the test statistic for that
distribution is less than the test statistic threshold, the
distribution and its corresponding subgroup are removed from the
overall group used to calculate the mean curve.
The subgroup and remainder of the original group are assigned to new,
separate groups. Once all distributions have been checked against
their mean distributions, the new groups are used to calculated
updated mean distributions.</p>
<h2 id="extract_list">extract_list</h2>
<pre><code class="python">extract_list(nested_list:list) -&gt; list
</code></pre>

<p>Extract all of the elements from the sublists within the list and
return the elements as a list.</p>
<h2 id="map_curve_groups">map_curve_groups</h2>
<pre><code class="python">map_curve_groups(curve_group:dict, curve_group1:dict, ungroup:bool=False) -&gt; dict
</code></pre>

<p>Map the temporary event keys back to the orignal event IDs to keep a
record of events within each group.</p>
<h2 id="renumber_dic_keys">renumber_dic_keys</h2>
<pre><code class="python">renumber_dic_keys(updated_group:dict, group_start_num:int) -&gt; dict
</code></pre>

<p>Renumber the dictionary keys so that they are ascending.</p>
<h2 id="final_test_stat">final_test_stat</h2>
<pre><code class="python">final_test_stat(updated_group:dict, updated_curves:pandas.core.frame.DataFrame, df:pandas.core.frame.DataFrame, convEpsilon:float, volEpsilon:float) -&gt; dict
</code></pre>

<p>For each group of distributions, the test statistic for each temporal
distribution and corresponding mean temporal distribution (the group
average) is calculated.</p>
<h2 id="dic_to_list">dic_to_list</h2>
<pre><code class="python">dic_to_list(dic:dict, get_set:bool=False) -&gt; list
</code></pre>

<p>Extracts the values from each key within a dictionary and returns the
values as a single list.</p>
<h2 id="calc_group_weight">Calc_Group_Weight</h2>
<pre><code class="python">Calc_Group_Weight(final_groups:dict, duration_weight:float, display_print:bool=True) -&gt; dict
</code></pre>

<p>Calculates the weight of each group of curves, such that the sum of
all the weights adds to the duration_weight.</p>
<h2 id="rename_final_groups">Rename_Final_Groups</h2>
<pre><code class="python">Rename_Final_Groups(curve_weight:dict, dur:int) -&gt; dict
</code></pre>

<p>Sorts the groups by their weight and then renames the groups so that
the group with the largest weight is designed E0001 and the group with
the next largest weight is designated E0002 (for the 6 hour duration).
The thounsands place is set to 0, 1, 2, 3 for the 6, 12, 24, and 96
hour durations, respectively. A dictionary mapping the original group
names to the new group names is returned.</p>
<h2 id="dic_key_to_str">dic_key_to_str</h2>
<pre><code class="python">dic_key_to_str(orig_dic:dict) -&gt; dict
</code></pre>

<p>Converts the keys of the passed dictionary to strings.</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
